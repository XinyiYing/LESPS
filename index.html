<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<link href="LESPS.css" rel="stylesheet" type="text/css" />

<meta name="GENERATOR" content="MSHTML 11.00.10570.1001"></head>
<body onLoad=" ">
<div id="container" class="STYLE37">


<meta name="GENERATOR" content="MSHTML 11.00.10570.1001"></head>
<body onLoad=" ">
<div id="container" class="STYLE37">

<br>
<p class="styleTittle" align="center">Mapping Degeneration Meets Label Evolution: Learning Infrared Small Target Detection with Single Point Supervision</p><br>
<p align="center"><span class="STYLEAuthor"> 
</span> 
</p>
<br>


<p class="STYLESection" align="center">Abstract</p>
<hr style="BORDER-LEFT-STYLE: none; BORDER-TOP: gray 3px groove; HEIGHT: 0px; BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none">
<div style="padding:20px 20px 20px 20px; font-size=20; color: #333; ">
	<p style="padding:15px 15px 15px 15px; background-color:#EEE; font-size:16px; font-family:PmingLiu; line-height:23px;", align="justify">
		Training a convolutional neural network (CNN) to detect infrared small targets in a fully supervised manner has gained remarkable research interests in recent years, but is highly labor expensive since a large number of per-pixel annotations are required. To handle this problem, in this paper, we make the first attempt to achieve infrared small target detection with point-level supervision. Interestingly, during the training phase supervised by point labels, we discover that CNNs first learn to segment a cluster of pixels near the targets, and then gradually converge to predicting groundtruth point labels. Motivated by this ''mapping degeneration'' phenomenon, we propose a label evolution framework named Label Evolution with Single Point Supervision (LESPS) to progressively expand the point label by leveraging the intermediate predictions of CNNs. In this way, the network predictions can finally approximate the updated pseudo labels, and a pixel-level target mask can be obtained to train CNNs in an end-to-end manner. We conduct extensive experiments with insightful visualizations to validate the effectiveness of our method. Experimental results show that CNNs equipped with LESPS can well recover the target masks from corresponding point labels, and can achieve over 70% and 95% of their fully supervised performance in terms of pixel-level intersection over union (IoU) and object-level probability of detection (Pd), respectively. Code is submitted for review and will be released upon acceptance.
	</p>
</div>
<br><br>

<p class="STYLESection" align="center">The Mapping Degeneration Phenomenon</p>
<hr style="BORDER-LEFT-STYLE: none; BORDER-TOP: gray 3px groove; HEIGHT: 0px; BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none">
<table width="100%" border="0">
  <tbody>
  <tr>
    <th scope="col"><img src="./Figs/MD1.jpg" width="80%"></th></tr></tbody></table>
<p class="styleCaption" align="justify">Fig. 1: Illustrations of mapping degeneration under point supervision. CNNs always tend to segment a cluster of pixels near the targets with low confidence at the early stage, and then gradually learn to predict groundtruth point labels with high confidence.</p><br><br><br>

<p class="styleCaption" align="justify">We develop an <b>online interactive demo</b> to show the mapping degeneration phenomenon. You can adjust the epoch number by dragging the sliding blocks.</p><br><br>

<!-- Scene1 -->
<!-- Figure -->
<div id="Scene1_father" style="width: 900; height: 582px;">
  <div id="Scene1_box2", class="wrapper", style="width:900px; height:582px; position: absolute; left: 512px;">
      <div class="middle"> <img id="Scene1_img2", src="Figs/scene1/image.png", style="width:900px; height:582px;", draggable="false"> 
        <div id='test1', style="position: absolute; top: 23px; left: 570px; font-size: 28px; background:#000; color: #FFF">Image</div>
      </div>
      <div class="top"> <img id="Scene1_img1", src="Figs/scene1/epoch34.png", style="width:900px; height:582px;", draggable="false"> 
        <div id='test2', style="position: absolute; top: 23px; left: 116px;  font-size: 28px; background:#000; color: #FFF">Feature</div>
      </div>
      <div id="Scene1_scroller_box", class="scroller scroller-top">
      <svg id="Scene1_scroller", class="scroller__thumb" xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 100 100">
        <polygon points="0 50 37 68 37 32 0 50" style="fill:#FFAB91">
        <polygon points="100 50 64 32 64 68 100 50" style="fill:#FFAB91">
      </svg>		
      </div>
</div>
</div>
<br>

<!-- Single slider for Noise -->
<link rel="stylesheet" href="slider.css">
<p class="STYLEAuthor" align="center"><b>Epoch Number 1-300</b></p>
<div id="Scene1_slider_noise" class="range-slider grad" style='--min:1; --max:300; --step:1; --value:34; --text-value:"34"; --prefix:""'>
	<input id="Scene1_noise_value" type="range" min="1" max="300" step="1" value="34" oninput="this.parentNode.style.setProperty('--value',this.value); 
	this.parentNode.style.setProperty('--text-value', JSON.stringify((+this.value).toLocaleString()))">
	<output></output>
	<div class='range-slider__progress'></div>
</div>
<br>
<br>
<br>
<br>
<br>

<!-- Scene2 -->
<!-- Figure -->
<div id="Scene2_father" style="width: 900; height: 573px;">
  <div id="Scene2_box2", class="wrapper", style="width:900px; height:573px; position: absolute; left: 512px;">
      <div class="middle"> <img id="Scene2_img2", src="Figs/scene2/image.png", style="width:900px; height:573px;", draggable="false"> 
        <div id='test1', style="position: absolute; top: 20px; left: 565px; font-size: 28px; background:#000; color: #FFF">Image</div>
      </div>
      <div class="top"> <img id="Scene2_img1", src="Figs/scene2/epoch75.png", style="width:900px; height:573px;", draggable="false"> 
        <div id='test2', style="position: absolute; top: 20px; left: 115px;  font-size: 28px; background:#000; color: #FFF">Feature</div>
      </div>
      <div id="Scene2_scroller_box", class="scroller scroller-top">
      <svg id="Scene2_scroller", class="scroller__thumb" xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 100 100">
        <polygon points="0 50 37 68 37 32 0 50" style="fill:#FFAB91">
        <polygon points="100 50 64 32 64 68 100 50" style="fill:#FFAB91">
      </svg>		
      </div>
</div>
</div>
<br>

<!-- Single slider for Noise -->
<link rel="stylesheet" href="slider.css">
<p class="STYLEAuthor" align="center"><b>Epoch Number 1-300</b></p>
<div id="Scene2_slider_noise" class="range-slider grad" style='--min:1; --max:300; --step:1; --value:75; --text-value:"75"; --prefix:""'>
	<input id="Scene2_noise_value" type="range" min="1" max="300" step="1" value="75" oninput="this.parentNode.style.setProperty('--value',this.value); 
	this.parentNode.style.setProperty('--text-value', JSON.stringify((+this.value).toLocaleString()))">
	<output></output>
	<div class='range-slider__progress'></div>
</div>
<br>
<br>
<br>
<br>
<br>

<!-- Scene3 -->
<!-- Figure -->
<div id="Scene3_father" style="width: 900; height: 510px;">
  <div id="Scene3_box2", class="wrapper", style="width:900px; height:510px; position: absolute; left: 512px;">
      <div class="middle"> <img id="Scene3_img2", src="Figs/scene3/image.png", style="width:900px; height:510px;", draggable="false"> 
        <div id='test1', style="position: absolute; top: 22px; left: 630px; font-size: 28px; background:#000; color: #FFF">Image</div>
      </div>
      <div class="top"> <img id="Scene3_img1", src="Figs/scene3/epoch23.png", style="width:900px; height:510px;", draggable="false"> 
        <div id='test2', style="position: absolute; top: 22px; left: 52px;  font-size: 28px; background:#000; color: #FFF">Feature</div>
      </div>
      <div id="Scene3_scroller_box", class="scroller scroller-top">
      <svg id="Scene3_scroller", class="scroller__thumb" xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 100 100">
        <polygon points="0 50 37 68 37 32 0 50" style="fill:#FFAB91">
        <polygon points="100 50 64 32 64 68 100 50" style="fill:#FFAB91">
      </svg>		
      </div>
</div>
</div>
<br>

<!-- Single slider for Noise -->
<link rel="stylesheet" href="slider.css">
<p class="STYLEAuthor" align="center"><b>Epoch Number 1-300</b></p>
<div id="Scene3_slider_noise" class="range-slider grad" style='--min:1; --max:300; --step:1; --value:23; --text-value:"23"; --prefix:""'>
	<input id="Scene3_noise_value" type="range" min="1" max="300" step="1" value="23" oninput="this.parentNode.style.setProperty('--value',this.value); 
	this.parentNode.style.setProperty('--text-value', JSON.stringify((+this.value).toLocaleString()))">
	<output></output>
	<div class='range-slider__progress'></div>
</div>
<br>
<br>
<br>
<br>
<br>

<body>	
  <script type="text/javascript">
    // box是装图片的容器,fa是图片移动缩放的范围,scale是控制缩放的小图标
  var Scene1_box2 = document.getElementById("Scene1_box2");
      var Scene1_fa = document.getElementById('Scene1_father');
  var Scene1_scroller_box = document.getElementById("Scene1_scroller_box");
  var Scene1_scroller = document.getElementById("Scene1_scroller");
  var Scene1_img1 = document.getElementById("Scene1_img1");
  var Scene1_img2 = document.getElementById("Scene1_img2");
  var Scene1_slider_noise = document.getElementById("Scene1_slider_noise");

  // 读取Noise
  Scene1_slider_noise.onmouseup = function (e) {
    var Scene1_noise = document.getElementById("Scene1_noise_value").value;
    Scene1_noise = parseInt(Scene1_noise);
    Scene1_img1.src = "Figs/scene1/epoch" + Scene1_noise + ".png";
  }

  </script>

  <script type="text/javascript">
    // box是装图片的容器,fa是图片移动缩放的范围,scale是控制缩放的小图标
  var Scene2_box2 = document.getElementById("Scene2_box2");
      var Scene2_fa = document.getElementById('Scene2_father');
  var Scene2_scroller_box = document.getElementById("Scene2_scroller_box");
  var Scene2_scroller = document.getElementById("Scene2_scroller");
  var Scene2_img1 = document.getElementById("Scene2_img1");
  var Scene2_img2 = document.getElementById("Scene2_img2");
  var Scene2_slider_noise = document.getElementById("Scene2_slider_noise");

  // 读取Noise
  Scene2_slider_noise.onmouseup = function (e) {
    var Scene2_noise = document.getElementById("Scene2_noise_value").value;
    Scene2_noise = parseInt(Scene2_noise);
    Scene2_img1.src = "Figs/scene2/epoch" + Scene2_noise + ".png";
  }

  </script>

  <script type="text/javascript">
    // box是装图片的容器,fa是图片移动缩放的范围,scale是控制缩放的小图标
  var Scene3_box2 = document.getElementById("Scene3_box2");
      var Scene3_fa = document.getElementById('Scene3_father');
  var Scene3_scroller_box = document.getElementById("Scene3_scroller_box");
  var Scene3_scroller = document.getElementById("Scene3_scroller");
  var Scene3_img1 = document.getElementById("Scene3_img1");
  var Scene3_img2 = document.getElementById("Scene3_img2");
  var Scene3_slider_noise = document.getElementById("Scene3_slider_noise");

  // 读取Noise
  Scene3_slider_noise.onmouseup = function (e) {
    var Scene3_noise = document.getElementById("Scene3_noise_value").value;
    Scene3_noise = parseInt(Scene3_noise);
    Scene3_img1.src = "Figs/scene3/epoch" + Scene3_noise + ".png";
  }

  </script>

  <script>
	// I hope this over-commenting helps. Let's do this!
	// Let's use the 'active' variable to let us know when we're using it
	let Scene1_active = false;
	let Scene1_scrollerTop = document.querySelectorAll('.scroller-top')[0];


	// First we'll have to set up our event listeners
	// We want to watch for clicks on our scroller
	Scene1_scrollerTop.addEventListener('mousedown',function(){
		Scene1_active = "top";
		Scene1_scrollerTop.classList.add('scrolling');
	});
	document.body.addEventListener('mouseup',function(){
		Scene1_active = false;
		Scene1_scrollerTop.classList.remove('scrolling');
	});
	document.body.addEventListener('mouseleave',function(){
		Scene1_active = false;
		Scene1_scrollerTop.classList.remove('scrolling');
	});

	// Let's figure out where their mouse is at
	document.body.addEventListener('mousemove',function(e){
	  if (!Scene1_active) return;
	  // Their mouse is here...
	  let x = e.pageX;
	  // but we want it relative to our wrapper
	  x -= document.querySelectorAll('.wrapper')[0].getBoundingClientRect().left;
	  // Okay let's change our state
	  scrollIt(x);
	});

	// Let's use this function
	function scrollIt(x){
	  // Calculate our transform
	  let transform = Math.max(0,(Math.min(x,document.querySelector('.wrapper').offsetWidth)));
	  // we show all our bottom image but how much of our middle and top,
	  // that'll depend on what we're dragging
	  // if we're dragging the top slider
	  if (Scene1_active==="top"){
		document.querySelectorAll('.top')[0].style.width = transform+"px";
		Scene1_scrollerTop.style.left = transform-25+"px";
		// if we're using scroller-top, top must always be to the left
	  }
	}

	// Let's set our opening state based off the width, 
	// we want to show a bit of both images so the user can see what's going on
	Scene1_active = "top";
	scrollIt(230);
	Scene1_active = false;


	// And finally let's repeat the process for touch events
	Scene1_scrollerTop.addEventListener('touchstart',function(){
		Scene1_active = "top";
		Scene1_scrollerTop.classList.add('scrolling');
	});
	document.body.addEventListener('touchend',function(){
		Scene1_active = false;
		Scene1_scrollerTop.classList.remove('scrolling');
	});
	document.body.addEventListener('touchcancel',function(){
		Scene1_active = false;
		Scene1_scrollerTop.classList.remove('scrolling');
	});

	document.querySelectorAll('.wrapper')[0].addEventListener('touchmove',function(e){
		if (!Scene1_active) return;
		e.preventDefault();
		let x = e.touches[0].pageX;
		x -= document.querySelectorAll('.wrapper')[0].getBoundingClientRect().left;
		scrollIt(x);
	});
	</script>

	<script>
		// I hope this over-commenting helps. Let's do this!
		// Let's use the 'active' variable to let us know when we're using it
		let Scene2_active = false;
		let Scene2_scrollerTop = document.querySelectorAll('.scroller-top')[1];
	
	
		// First we'll have to set up our event listeners
		// We want to watch for clicks on our scroller
		Scene2_scrollerTop.addEventListener('mousedown',function(){
			Scene2_active = "top";
			Scene2_scrollerTop.classList.add('scrolling');
		});
		document.body.addEventListener('mouseup',function(){
			Scene2_active = false;
			Scene2_scrollerTop.classList.remove('scrolling');
		});
		document.body.addEventListener('mouseleave',function(){
			Scene2_active = false;
			Scene2_scrollerTop.classList.remove('scrolling');
		});
	
		// Let's figure out where their mouse is at
		document.body.addEventListener('mousemove',function(e){
		  if (!Scene2_active) return;
		  // Their mouse is here...
		  let x = e.pageX;
		  // but we want it relative to our wrapper
		  x -= document.querySelectorAll('.wrapper')[1].getBoundingClientRect().left;
		  // Okay let's change our state
		  Scene2_scrollIt(x);
		});
	
		// Let's use this function
		function Scene2_scrollIt(x){
		  // Calculate our transform
		  let transform = Math.max(0,(Math.min(x,document.querySelector('.wrapper').offsetWidth)));
		  // we show all our bottom image but how much of our middle and top,
		  // that'll depend on what we're dragging
		  // if we're dragging the top slider
		  if (Scene2_active==="top"){
			document.querySelectorAll('.top')[1].style.width = transform+"px";
			Scene2_scrollerTop.style.left = transform-25+"px";
			// if we're using scroller-top, top must always be to the left
		  }
		}
	
		// Let's set our opening state based off the width, 
		// we want to show a bit of both images so the user can see what's going on
		Scene2_active = "top";
		Scene2_scrollIt(230);
		Scene2_active = false;
	
	
		// And finally let's repeat the process for touch events
		Scene2_scrollerTop.addEventListener('touchstart',function(){
			Scene2_active = "top";
			Scene2_scrollerTop.classList.add('scrolling');
		});
		document.body.addEventListener('touchend',function(){
			Scene2_active = false;
			Scene2_scrollerTop.classList.remove('scrolling');
		});
		document.body.addEventListener('touchcancel',function(){
			Scene2_active = false;
			Scene2_scrollerTop.classList.remove('scrolling');
		});
	
		document.querySelectorAll('.wrapper')[1].addEventListener('touchmove',function(e){
			if (!Scene2_active) return;
			e.preventDefault();
			let x = e.touches[0].pageX;
			x -= document.querySelectorAll('.wrapper')[1].getBoundingClientRect().left;
			scrollIt(x);
		});
		</script>

    <script>
	// I hope this over-commenting helps. Let's do this!
	// Let's use the 'active' variable to let us know when we're using it
	let Scene3_active = false;
	let Scene3_scrollerTop = document.querySelectorAll('.scroller-top')[2];


	// First we'll have to set up our event listeners
	// We want to watch for clicks on our scroller
	Scene3_scrollerTop.addEventListener('mousedown',function(){
		Scene3_active = "top";
		Scene3_scrollerTop.classList.add('scrolling');
	});
	document.body.addEventListener('mouseup',function(){
		Scene3_active = false;
		Scene3_scrollerTop.classList.remove('scrolling');
	});
	document.body.addEventListener('mouseleave',function(){
		Scene3_active = false;
		Scene3_scrollerTop.classList.remove('scrolling');
	});

	// Let's figure out where their mouse is at
	document.body.addEventListener('mousemove',function(e){
	  if (!Scene3_active) return;
	  // Their mouse is here...
	  let x = e.pageX;
	  // but we want it relative to our wrapper
	  x -= document.querySelectorAll('.wrapper')[2].getBoundingClientRect().left;
	  // Okay let's change our state
	  Scene3_scrollIt(x);
	});

	// Let's use this function
	function Scene3_scrollIt(x){
	  // Calculate our transform
	  let transform = Math.max(0,(Math.min(x,document.querySelector('.wrapper').offsetWidth)));
	  // we show all our bottom image but how much of our middle and top,
	  // that'll depend on what we're dragging
	  // if we're dragging the top slider
	  if (Scene3_active==="top"){
		document.querySelectorAll('.top')[2].style.width = transform+"px";
		Scene3_scrollerTop.style.left = transform-25+"px";
		// if we're using scroller-top, top must always be to the left
	  }
	}

	// Let's set our opening state based off the width, 
	// we want to show a bit of both images so the user can see what's going on
	Scene3_active = "top";
	Scene3_scrollIt(230);
	Scene3_active = false;


	// And finally let's repeat the process for touch events
	Scene3_scrollerTop.addEventListener('touchstart',function(){
		Scene3_active = "top";
		Scene3_scrollerTop.classList.add('scrolling');
	});
	document.body.addEventListener('touchend',function(){
		Scene3_active = false;
		Scene3_scrollerTop.classList.remove('scrolling');
	});
	document.body.addEventListener('touchcancel',function(){
		Scene3_active = false;
		Scene3_scrollerTop.classList.remove('scrolling');
	});

	document.querySelectorAll('.wrapper')[2].addEventListener('touchmove',function(e){
		if (!Scene3_active) return;
		e.preventDefault();
		let x = e.touches[0].pageX;
		x -= document.querySelectorAll('.wrapper')[2].getBoundingClientRect().left;
		scrollIt(x);
	});
	</script>
<br><br>


<p class="STYLESection" align="center">The Label Evolution Framework</p>
<hr style="BORDER-LEFT-STYLE: none; BORDER-TOP: gray 3px groove; HEIGHT: 0px; BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none">
<table width="100%" border="0">
  <tbody>
  <tr>
    <th scope="col"><img src="./Figs/LESPS.jpg" width="80%"></th></tr></tbody></table>
<p class="styleCaption" align="justify">Fig. 2: Illustrations of Label Evolution with Single Point Supervision (LESPS). During training, intermediate predictions of CNNs are used to progressively expand point labels to mask labels. Black arrows represent each round of label updates.</p><br><br><br>

<p class="STYLESection" align="center">Quantitative Results</p>
<hr style="BORDER-LEFT-STYLE: none; BORDER-TOP: gray 3px groove; HEIGHT: 0px; BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none">
<br>
<p class="styleCaption" align="justify">Table 1: IoU (×10e2), Pd (×10e2) and Fa(×10e6) values of different methods achieved on NUAA-SIRST, NUDT-SIRST and IRSTD-1K. “CNN Full”, “CNN Centroid”, and “CNN Coarse” represent CNN-based methods under full supervision, centroid and coarse point supervision. “+” represents CNN-based methods equipped with LESPS.</p>
<table width="100%" border="0">
  <tbody>
  <tr>
    <th scope="col"><img src="./Figs/table1.jpg" width="100%"></th></tr></tbody></table>
<br><br>

<p class="styleCaption" align="justify">Table 2: Average IoU (×10e2), Pd (×10e2) and Fa(×10e6) values on NUAA-SIRST, NUDT-SIRST and IRSTD-1K of DNAnet trained with pseudo labels generated by different LCM-based methods and LESPS under centroid and coarse point supervision.</p>
<table width="100%" border="0">
  <tbody>
  <tr>
    <th scope="col"><img src="./Figs/table2.jpg" width="50%"></th></tr></tbody></table>
<br><br><br>

<p class="STYLESection" align="center">Qualitative Results</p>
<hr style="BORDER-LEFT-STYLE: none; BORDER-TOP: gray 3px groove; HEIGHT: 0px; BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none">
<br>
<table width="100%" border="0">
  <tbody>
  <tr>
    <th scope="col"><img src="./Figs/visual1.jpg" width="100%"></th></tr></tbody></table>
<p class="styleCaption" align="justify">Fig. 3: Visualizations of regressed labels during training and network predictions during inference with centroid and coarse point supervision.</p><br><br>

<table width="100%" border="0">
  <tbody>
  <tr>
    <th scope="col"><img src="./Figs/visual2.jpg" width="80%"></th></tr></tbody></table>
<p class="styleCaption" align="justify">Fig. 4: Visual detection results of different methods achieved on NUAA-SIRST, NUDT-SIRST and IRSTD-1K. Correctly detected targets and false alarms are highlighted by red and orange circles, respectively.</p><br><br><br>

<div style="padding:10px 0px 5px 0px">
	<p class="STYLESection" align="center">Materials</p>
</div>
<hr align="right", width="85%", style="BORDER-LEFT-STYLE: none; BORDER-TOP: gray 3px groove; HEIGHT: 0px; BORDER-BOTTOM-STYLE: none; BORDER-RIGHT-STYLE: none; margin:auto">

<div style="padding:12px 0px 10px 120px;", class="one" align="center">
  <div style=" float: left" >
  <a href="https://openreview.net/pdf?id=jdt7pLZyWR">
  <img src="Figs/paper.png" height="150">
  <p style="padding:0px 0px 20px 0px">Paper</p>
  </a>
</div>
<div >
  <a href="https://github.com/CVPR2023ID6230/LESPS">
  <img src="Figs/github.jpg" height="150">
  <p style="padding:0px 0px 20px 0px">Code</p>
  </a>
</div>
</div>


</pre></div>
</body></html>

